# パフォーマンスガイド

このガイドでは、nvecd のパフォーマンス最適化のヒントとベストプラクティスを提供します。

## パフォーマンス機能

Nvecd は以下の最適化により、高性能なベクトル類似検索を実現しています：

### 1. SIMD アクセラレーション

**自動CPU検出**

Nvecd は起動時に CPU を自動検出し、利用可能な最適な SIMD 命令を使用します：

- **ARM (Apple Silicon, ARM サーバー)**: NEON SIMD (4ワイド演算)
- **x86_64 (Intel, AMD)**: AVX2 SIMD (8ワイド演算)
- **フォールバック**: 古い CPU 向けスカラー実装

**パフォーマンスへの影響:**

| 演算 | スカラー | NEON (ARM64) | AVX2 (x86_64) |
|------|---------|--------------|---------------|
| ドット積 (768次元) | 基準 | **3-4倍高速** | **6-8倍高速** |
| コサイン類似度 | 基準 | **2.5-3倍高速** | **5-6倍高速** |

**確認方法:**

サーバー起動時のログを確認：
```
[info] Vector SIMD: NEON      # ARM64
[info] Vector SIMD: AVX2      # x86_64
[info] Vector SIMD: Scalar    # フォールバック
```

### 2. スマートクエリキャッシング

**LRU キャッシュ + 圧縮**

Nvecd はインテリジェントなキャッシュシステムを使用：
- 高コストなクエリ結果をキャッシュ（閾値設定可能）
- LZ4 で結果を圧縮（メモリ使用量 75% 削減）
- データ更新時に自動で古いエントリを無効化

**設定:**

```yaml
cache:
  enabled: true
  max_memory_mb: 32          # 最大キャッシュサイズ
  min_query_cost_ms: 10.0    # 10ms 以上のクエリのみキャッシュ
  compression_enabled: true
```

**キャッシュ統計:**

```bash
echo "CACHE STATS" | nc localhost 11017
```

出力:
```
total_queries: 10000
cache_hits: 8500
cache_misses: 1500
hit_rate: 0.8500
current_entries: 2450
current_memory_mb: 12.45
evictions: 320
avg_hit_latency_ms: 0.05
time_saved_ms: 15420.50
```

**主要メトリクス:**
- `hit_rate`: 0.85 = 85% のクエリがキャッシュから提供
- `time_saved_ms`: キャッシュヒットにより節約された合計レイテンシ
- `avg_hit_latency_ms`: キャッシュルックアップ時間（約 0.05ms）

### 3. 自動キャッシュ無効化

**スマート無効化:**

データ更新時に、影響を受けるキャッシュエントリを自動的に無効化：

| イベント | 無効化されるキャッシュ |
|---------|---------------------|
| `VECSET` (ベクトル更新) | その ID の SIM クエリ |
| `EVENT` (共起追加) | Fusion クエリ（events モード影響） |

**手動キャッシュ管理:**

```bash
# 全キャッシュをクリア
echo "CACHE CLEAR" | nc localhost 11017

# キャッシュ状態確認
echo "CACHE STATS" | nc localhost 11017
```

## 最適化のヒント

### 1. 適切な検索モードの選択

```yaml
# SIM <id> <top_k> <mode>
```

**モード:**

| モード | 用途 | パフォーマンス |
|--------|------|---------------|
| `vectors` | 純粋なコンテンツ類似性 | 最速（SIMD のみ） |
| `events` | 純粋な行動パターン | 高速（ビットマップルックアップ） |
| `fusion` | ハイブリッド推薦 | 中程度（SIMD + ビットマップ） |

**推奨:**
- コンテンツベース検索には `vectors` から開始
- 協調フィルタリング（「X を好んだユーザーは Y も好む」）には `events`
- 両方のシグナルが必要な場合は `fusion`

### 2. キャッシュチューニング

**min_query_cost_ms の調整:**

```yaml
cache:
  min_query_cost_ms: 10.0    # 10ms 以上のクエリのみキャッシュ
```

**ガイドライン:**
- **小規模データセット（<10K ベクトル）**: `5.0` に設定（ほとんどのクエリが高速）
- **中規模データセット（10K-100K）**: `10.0`（デフォルト）
- **大規模データセット（>100K）**: `20.0`（遅いクエリのみキャッシュ）

**メモリ vs ヒット率のトレードオフ:**

```yaml
cache:
  max_memory_mb: 32    # 低メモリ: キャッシュされるクエリが少ない
  max_memory_mb: 128   # 高メモリ: キャッシュされるクエリが多い
```

`CACHE STATS` でモニタリングし、ヒット率に基づいて調整してください。

### 3. ベクトル次元の選択

**次元が小さい = クエリが高速**

| 次元 | 典型的な用途 | クエリ時間* |
|------|-------------|------------|
| 128 | 高速ルックアップ、中程度の品質 | 約 0.5ms |
| 384 | バランス型（sentence transformers） | 約 1.5ms |
| 768 | 高品質（BERT 埋め込み） | 約 3ms |
| 1536 | 非常に高品質（OpenAI） | 約 6ms |

\* 10K ベクトル、AVX2 での近似クエリ時間

**推奨:**
- 384 次元埋め込みから開始（品質と速度のバランスが良い）
- 品質が重要でデータセットが <100K ベクトルなら 768 を使用
- サブミリ秒レイテンシが必要なら 128 を使用

### 4. バッチ操作

**大量のベクトルを登録:**

クライアントライブラリを使用して VECSET コマンドをバッチ処理：

```cpp
#include <nvecdclient.h>

nvecdclient::NvecdClient client(config);
client.Connect();

// 1000 ベクトルをバッチ処理
for (const auto& [id, vector] : vectors) {
    client.Vecset(id, vector);  // TCP 接続を再利用
}
```

**避けるべき:** ベクトルごとに接続を開閉（TCP オーバーヘッド）

### 5. イベントバッファサイズ

```yaml
events:
  ctx_buffer_size: 1000    # コンテキストごとのイベント数
```

**ガイドライン:**
- **ユーザーセッション**: 100-500（典型的なセッション長）
- **商品閲覧**: 500-1000（より多くのアクティビティ）
- **長期トラッキング**: 1000-5000（数日間のセッション）

バッファが大きい = メモリ使用量増加、推薦品質向上

## 本番環境デプロイメント

### 1. メモリサイジング

**経験則:**

```
メモリ = (ベクトル数 × 次元 × 4バイト) + イベントメモリ + オーバーヘッド
```

**例:**
- 100K ベクトル × 768次元 × 4バイト = 307MB（ベクトル）
- 10K コンテキスト × 1000イベント × 50バイト = 500MB（イベント）
- **合計: 約 1GB 最小、2GB 推奨**

### 2. モニタリング

**ヘルスチェック:**

```bash
# Liveness probe (Kubernetes)
curl http://localhost:8080/health/live
# → 200 OK

# Readiness probe (ロードバランサー)
curl http://localhost:8080/health/ready
# → 200 OK (準備完了) または 503 (スナップショット読み込み中)

# 詳細メトリクス
curl http://localhost:8080/health/detail
```

**監視すべき主要メトリクス:**

```json
{
  "uptime_seconds": 3600,
  "total_requests": 15000,
  "memory": {
    "vector_store_bytes": 307200000,
    "event_store_bytes": 524288000,
    "cache_bytes": 13107200
  },
  "cache": {
    "hit_rate": 0.85,
    "time_saved_ms": 15420.50
  }
}
```

### 3. バックアップ戦略

**定期スナップショット:**

```bash
# 手動スナップショット
echo "DUMP SAVE /backup/nvecd-$(date +%Y%m%d-%H%M%S).dmp" | nc localhost 11017

# 自動化された日次スナップショット (cron)
0 2 * * * echo "DUMP SAVE" | nc localhost 11017
```

**スナップショットパフォーマンス:**
- 100K ベクトル（768次元）+ 1M イベント: 約 500ms 保存時間、約 300MB ファイルサイズ
- スナップショットはアトミック（サービス中断なし）

### 4. 高可用性

**ロードバランサー構成:**

```
┌─────────────┐
│ ロード       │
│ バランサー   │
└─────┬───────┘
      │
  ┌───┴───┬───────┬───────┐
  │       │       │       │
┌─▼──┐  ┌─▼──┐  ┌─▼──┐  ┌─▼──┐
│nvecd│  │nvecd│  │nvecd│  │nvecd│
│ #1  │  │ #2  │  │ #3  │  │ #4  │
└─────┘  └─────┘  └─────┘  └─────┘
```

**設定:**
- 各インスタンスは起動時に同じスナップショットを読み込む
- ロードバランサーのヘルスチェックに `/health/ready` を使用
- 更新（VECSET/EVENT）は書き込みコーディネーター経由で実行（図示せず）

**注意:** nvecd は現在マルチマスターレプリケーションに対応していません。書き込み操作には、単一のプライマリインスタンスを使用するか、アプリケーションレベルの書き込み調整を実装してください。

## パフォーマンスベンチマーク

### 典型的なクエリパフォーマンス

**環境:**
- Apple M1 (NEON SIMD)
- 10K ベクトル (768次元)
- 50K イベント、5K コンテキスト

**結果:**

| クエリタイプ | モード | コールド（キャッシュなし） | ウォーム（キャッシュあり） |
|-------------|------|---------------------------|---------------------------|
| SIM (ID検索) | vectors | 2.5ms | 0.05ms |
| SIM (ID検索) | events | 0.8ms | 0.05ms |
| SIM (ID検索) | fusion | 3.2ms | 0.05ms |
| SIMV (ベクトルクエリ) | vectors | 2.8ms | 0.05ms |

**主要な発見:**
- SIMD 高速化: スカラーの 3-6 倍高速
- キャッシュヒットレイテンシ: 約 50 マイクロ秒（コールドの 50 倍高速）
- Fusion クエリ: 純粋なベクトル検索より 25% 遅いだけ

### スケーリング特性

**クエリレイテンシ vs データセットサイズ（vectors モード、768次元、AVX2）:**

| データセットサイズ | クエリ時間 |
|------------------|-----------|
| 1K ベクトル | 0.3ms |
| 10K ベクトル | 2.5ms |
| 100K ベクトル | 25ms |
| 1M ベクトル | 250ms |

**線形スケーリング:** データセットサイズに対して O(n)（ブルートフォース検索）

**キャッシュ効果:**

| ヒット率 | レイテンシ削減 |
|---------|---------------|
| 50% | 2倍高速 |
| 80% | 5倍高速 |
| 90% | 10倍高速 |

## トラブルシューティング

### クエリが予想より遅い

**1. SIMD が有効か確認:**

```bash
# ログで SIMD モードを確認
grep "Vector SIMD" /path/to/nvecd.log
# → Vector SIMD: NEON  (良好)
# → Vector SIMD: Scalar  (遅い、CPU を確認)
```

**2. デバッグモードを有効化:**

```bash
echo "DEBUG ON" | nc localhost 11017
echo "SIM vec123 10 vectors" | nc localhost 11017
# → クエリタイミングの詳細を表示
```

**3. キャッシュヒット率を確認:**

```bash
echo "CACHE STATS" | nc localhost 11017
# hit_rate < 0.5 の場合、検討事項:
# - max_memory_mb を増やす
# - min_query_cost_ms を下げる
```

### メモリ使用量が多い

**1. メモリ内訳を確認:**

```bash
curl http://localhost:8080/health/detail | jq '.memory'
```

**2. キャッシュサイズを削減:**

```yaml
cache:
  max_memory_mb: 16    # 32MB から削減
```

**3. イベントバッファを削減:**

```yaml
events:
  ctx_buffer_size: 500  # 1000 から削減
```

**4. スナップショット + 再起動:**

```bash
echo "DUMP SAVE /backup/snapshot.dmp" | nc localhost 11017
# クリーンな状態でサーバーを再起動
```

### キャッシュが機能しない

**1. キャッシュが有効か確認:**

```yaml
cache:
  enabled: true    # true である必要あり
```

**2. min_query_cost_ms 閾値を確認:**

```yaml
cache:
  min_query_cost_ms: 10.0
```

高速なクエリ（<10ms）はデフォルトでキャッシュされません。

**3. キャッシュ統計をモニタリング:**

```bash
echo "CACHE STATS" | nc localhost 11017
```

`total_queries > 0` だが `cache_hits = 0` の場合、クエリが高速すぎてキャッシュされていない可能性があります。

## ベストプラクティス

### 推奨事項

✅ **SIMD 対応 CPU を使用**（ARM64 NEON、x86_64 AVX2）
✅ **本番環境ではキャッシュを有効化**
✅ **キャッシュヒット率をモニタリング**して設定を調整
✅ **小さい次元を使用**（レイテンシが重要なら 384 より 1536）
✅ **クライアントライブラリでベクトルアップロードをバッチ処理**
✅ **災害復旧のため定期的にスナップショット取得**

### 避けるべき事項

❌ **本番環境でキャッシュを無効化しない**
❌ **4096 次元ベクトルを使用しない**（遅い、メモリ集約的）
❌ **クエリごとに接続を開閉しない**
❌ **モニタリングなしで運用しない**（`/health/detail`）
❌ **SIM で十分な場合に SIMV を使用しない**（SIMV はベクトルハッシュを計算）

## まとめ

Nvecd は以下により高性能なベクトル検索を提供します：

1. **SIMD 高速化**（ベクトル演算が 3-8 倍高速）
2. **スマートキャッシング**（繰り返しクエリが 50-100 倍高速）
3. **効率的なデータ構造**（圧縮イベント、最適化レイアウト）

10K-100K ベクトルの典型的なワークロードでは：
- **コールドクエリ**: 2-25ms
- **キャッシュクエリ**: 0.05ms（50マイクロ秒）
- **キャッシュヒット率**: 適切なチューニングで 70-90%

このガイドの最適化のヒントに従うことで、本番環境でサブミリ秒のクエリレイテンシを達成できます。
